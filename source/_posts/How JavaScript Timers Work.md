---
title: How JavaScript Timers Work
date: 2017-10-27 11:03:35
tags: [javascript, timers]
---

&emsp;&emsp;理解javascript的定时器的工作原理对于打好编程基础来说非常重要。因为他们运行在单线程的程式中，所以他们的表现总是不那么直观。让我们通过测试下面这三个函数来看看是如何创建和操作定时器的。

<!--more-->

&emsp;&emsp;1. var id = setTimeout(fn, delay);启动一个定时，在延迟数毫秒后调用指定函数。此方法会返回一个唯一的（定时器）id，方便在这之后取消这个定时器。

![](/images/26.jpeg)

&emsp;&emsp;2. var id = setInterval(fn, delay) ;和setTimeout非常相似，只不过它会间隔地一直调用指定函数，直到定时器被取消。

&emsp;&emsp;3. clearInterval(id);, clearTimeout(id);清除定时器方法，接受一个定时器id参数，并结束该定时器的回调。

&emsp;&emsp;为了理解定时器内部是如何工作的，这里有一个非常重要的概念需要说明一下：定时器的延迟是不能保证的。由于浏览器所有的javascirpt都是运行在一个单线程中，异步事件（比如点击事件，定时器）仅在被触发时候才会开始执行（比如点击事件的回调，需要点击事件触发才会去执行回调）。请看下面的图示：

&emsp;&emsp;这个图中有大量的信息需要消化，完全理解它有助于帮助你更好地理解javascript的异步事件编程。从纵向来看，我们有个以毫秒为单位的时钟，蓝色框代表正在执行的javascript部分。比如第一个蓝色盒子表示javascript大约执行了18毫秒，又比如第二个蓝色盒子代表javascript大约执行了11毫秒，等等。

&emsp;&emsp;因为javascript每次只能执行一段代码（由于其单线程的特性），每段代码的执行都会阻塞其他的异步事件的进程。这就意味着当一个异步事件被触发的时候（比如鼠标点击，定时器触发，或者XMLHttpRequest对象的完成事件）它的回调程序就会到执行队列中排队等待执行（实际上这种队列是如何实现的，每个浏览器可能不同，因此只能把它简单想成这样）。

&emsp;&emsp;首先，在第一块javascript代码（蓝色盒子）中，两个定时器被启动：一个10毫秒的setTimeout和一个10毫秒的setInterve。在第一块代码全部执行完毕之前，这两个定时器一定会被启动，但他们不会立即执行回调（由于单线程的原因），而是把延迟（回调）函数放在队列中，等待在下一个空闲的时候才会被执行。

&emsp;&emsp;此外，在第一个javascript代码块中有一个鼠标点击事件被触发。与它相关的javascript回调函数（我们不知道用户什么时候可以执行一个动作，因此认为它是异步的）也无法立即执行，像之前的计时器一样，它也是排在队列中等待执行。

&emsp;&emsp;在完成JavaScript第一块代码的执行之后，浏览器立即开始考虑一个问题：等待执行的有哪些？在这种情况下，鼠标单击处理程序和计时器回调都在等待。然后浏览器选择一个（鼠标单击回调）并立即执行它。计时器将等待到下一个可能的时间，才会执行。

&emsp;&emsp;注意，当鼠标单击回调处理程序正在执行时，第一个定时器回调将要被执行。因为interval的回调处理程序正在队列中排队等待执行，这时，当interval再次触发时，它这次需要执行的回调处理程序将被删除，也就是说不会重复进入队列。当一大段代码正在执行的时候，如果你让所有的定时器回调进入队列中排队，结果会是一堆没有间隙的回调一直被执行，直到所有执行完毕。相反，在其他的任务被放入队列排队之前，浏览器倾向于只是简单的等待，直到所有的定时回调任务都被执行完。

&emsp;&emsp;事实上，我们可以看到，当interval的回调正在执行时，第三个interval回调会发生这种情况。这告诉了我们一个重要的事实：intervals不在乎当前正在执行的是什么，他们只管尝试进入队列排队，即便两个回调之间的间隔的时间会被牺牲（这就是之前说的为什么定时器的延迟是不能保证的的原因）。

&emsp;&emsp;最后，在第二个interval回调完成后，我们可以看到JavaScript引擎没有什么可以执行的了。这意味着浏览器现在正在等待一个新的异步事件发生。当interval再次触发的时候，我们得到这个在50ms的标记。然而，这一次，没有任何东西阻止它的执行，所以它立即执行。

&emsp;&emsp;让我们看一个例子来更好地说明两者之间的区别。

```
setTimeout(function(){    

    ......

    setTimeout(arguments.callee,10);

},10);

setInterval(function(){

.......

},10);

```

&emsp;&emsp;这两段代码乍看起来可能在功能上是等价的，但它们不是。setTimeout回调执行会间隔上一次回调（任何代码）的执行至少有一个10ms的延时（有可能会更多，但不会少），而setInterval将试图每10ms执行一次回调不论上次是否执行。

&emsp;&emsp;让我们回顾一下这里学到的事情：

    1.JavaScript引擎只有一个线程，强制异步事件排队等待执行。

    2.setTimeout()和setInterval()在执行方面有着根本的不同。

    3.如果一个计时器被阻止立即执行，它将被延迟到下一个可能的执行点（这将比预期的延迟更长）。

    4.如果执行时间长（比指定的延迟时间长），则interval可以连续地执行回调。

&emsp;&emsp;所有这些都是非常重要的知识。了解JavaScript引擎是如何工作的，特别是在发生的大量异步事件的情况下，在构建高级应用程序代码时是一个很好的基础。


--- 译自Jquery作者John Resig's blog《How JavaScript Timers Work》,原文链接[https://johnresig.com/blog/how-javascript-timers-work/](https://johnresig.com/blog/how-javascript-timers-work/)