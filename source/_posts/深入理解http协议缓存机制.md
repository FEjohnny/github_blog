---
title: 深入理解http协议缓存机制
date: 2018-07-01 18:19:43
tags: javascript
---

&emsp;&emsp;缓存分为服务端缓存（比如nginx，apache）和客户端缓存（比如浏览器缓存）。服务端缓存又分为代理服务器缓存和反向代理服务器缓存（也叫网关缓存，像nginx反向代理等），我们平时广泛使用的CND就是一种服务端缓存，一般缓存的都是一些静态资源，比如js，css，images等，它的内容分发和缓存可以使客户端访问资源时走捷径，达到加速的目地；而客户端缓存一般指浏览器缓存，目地也是加速资源的访问。
<!--more-->

# 一、缓存的分类

&emsp;&emsp;这里顺便说一下正向代理和反向代理。正向代理是相对于客户端而言，它介于客户端和目标服务器之间，主要用于客户端不能直接访问某服务时，通过一个代理服务器接受客户端的请求，然后再去请求目标服务器的资源，最后返回给客户端，整个过程客户端对于目标服务器是不可见的，我们平时所谓的翻墙就是这么个原理。反向代理则是相对于服务器而言，客户端请求代理服务器，然后代理服务器去相应的服务器去拿到资源返回给客户端，整个过程中，最后处理请求并响应资源的服务器对于客户端来说是不可见的，通常会用它来做服务器的负载均衡。

# 二、浏览器缓存机制

&emsp;&emsp;浏览器缓存也分为两种，一种是通过html的meta标签来控制缓存，通过在html的head标签中插入meta标签来实现：

```
meta http-equiv="pragma" content="no-cache"
```

&emsp;&emsp;上面的代码就是告诉浏览器当前页面不被缓存，每次都去服务器拉取最新的资源。但是只有部分浏览器支持，而且所有的缓存代理服务器都不支持，因为代理服务器无法解析html标签。所以通常都是使用http头信息来控制缓存。

# 三、http协议中头信息控制缓存

&emsp;&emsp;浏览器首次请求流程图

![](/images/12.png)

&emsp;&emsp;浏览器再次请求流程图

![](/images/13.png)

## 1.expires策略

&emsp;&emsp;expires（它的值是一个具体的时间点）是服务器响应消息头字段，告诉浏览器在过期时间前可以直接使用缓存数据，无需再次请求。不过expires是http1.0的东西，现在浏览器普遍默认使用http1.1，所以它的作用基本可以忽略。

## 2.cathe-control策略（重点关注）

&emsp;&emsp;cathe-control的作用于expires的作用类似，都是指明当前资源的有限期，控制浏览器是直接读取缓存资源还是发送请求请求获取数据；不过cathe-control的选择更多，设置更细，如果和expires同时设置的话，它的优先级高于expires。cathe-control的可选值：
+ public: 可向任意方提供的缓存。
+ private: 只能向特定用户返回响应。
+ no-cathe: 缓存前必须先确认其有效性。
+ no-store: 不缓存请求或响应的任何内容。
+ max-age: 响应的最大age值，比如值为300，相对于缓存的有效期为5分钟，就是首次请求缓存的时间，之后的5分钟以内都可以直接使用缓存。
+ min-fresh: 期望在指定时间内的响应依然有效。
+ max-stale: 客户机可以接收超出超时期间的响应消息。

### Last-Modified/If-Modified-Since要和cache-control配合使用
- Last-Modified：标识该响应资源在服务器的最后修改时间。     
- If-Modified-Since：通过cache-control:max-age=300的值判断，当缓存过期的时候，若该资源具有last-modefied标识，在向服务器请求资源的时候，请求头带上if-modified-since:值为last-modified的值；服务器收到请求，发现有if-modified-since的请求头，就去比较资源的修改时间，如果较if-modified-since的值新，就返回新的资源，状态码是200，不然就返回304状态码，无实体返回，浏览器继续使用缓存资源。

### Etag/If-None-Match要和cache-control配合使用
+ Etag：服务器响应资源的时候，告诉浏览器该资源在服务器的唯一标识（生成规则由服务器决定），apache的默认生成规则是由文件的所以节（INode），大小（Size）和最后修改时间（Mtime）进行hash后得到。
+ If-None-Match：通过cache-control:max-age=300的值判断，当缓存过期的时候，若该资源具有Etag标识，在向服务器请求资源的时候，请求头带上If-None-Match：值为Etag的值；服务器收到请求后，发现If-None-Match的请求头，就去对该资源进行校验串比对，如果没有发生改变，就返回无实体的响应（304），客户端继续使用缓存资源，否则就返回200，新的资源。

&emsp;&emsp;为什么有可Last-Modified还需要Etag呢？http1.1Etag的出现，其实是为了解决Last-Modified比较难解决的问题：

+ 1.Last-Modified的时间只能精确到秒级，如果一个文件在1秒内多次修改，Last-Modified就无法准确表示其最后修改时间。
+ 2.如果有些资源是定期自动生成的，但是内容并没有发生改变，但是Last-Modified的值却改变来，导致缓存不可用，这是不怎么合理的。
+ 3.有可能服务器无法获取资源的修改时间，或者与缓存服务器不一致等情况。

&emsp;&emsp;Etag是由服务器自动生成或者开发者生成的对应资源在服务器的唯一标识符，能够更加精确地控制缓存。在同时使用Last-Modified和Etag的时候，服务器会有限校验Etag的值，才会对比Last-Modified，最后决定返回200还是304。

&emsp;&emsp;最后，浏览器的缓存行为还与用户行为有关，比如强制刷新（ctr+f5）这种操作也会影响缓存

用户操作与缓存的关系图

![](/images/14.png)