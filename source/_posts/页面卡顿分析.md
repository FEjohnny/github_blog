---
title: 页面卡顿分析
date: 2018-09-12 17:28:55
tags: [前端, 浏览器, 性能]
---

&emsp;&emsp;页面卡顿分析。

<!--more-->

&emsp;&emsp;

1. DOM节点太多？document.all
    100条数据：HTMLAllCollection(12976)
    500条数据：HTMLAllCollection(60972)

    建议懒加载：一次性加载大量数据是不必要的，建议优先加载可视区域的，剩余区域等可见时异步加载
    
2. DOM操作上惹得祸？
    DOM操作的代价很高，页面前端代码的性能瓶颈也大多集中在DOM操作上；
    通过JavaScript代码调用DOM接口，相当于两个独立模块的交互。相比较在同一模块中的调用，这种跨模块的调用其性能损耗是很高的；
    DOM操作对性能影响最大其实还是因为它导致了浏览器的重绘（repaint）和重排（reflow）；

    建议：
    合并多次的DOM操作为单次的DOM操作；
    把DOM元素离线或隐藏后修改；
    使用事件托管方式绑定事件；
    谨慎取得DOM元素的布局信息；
    设置具有动画效果的DOM元素的position属性为fixed或absolute；
    克隆DOM元素到内存中；

3. 前端经典问题，在JS中操作渲染大量DOM
    在JS当中直接操作DOM，会导致性能严重下降，所以渲染长列表（也就是大量DOM），会导致浏览器卡顿严重，甚至有可能出现假死状态。（这里延伸一个题外话，不通过JS渲染大量DOM是不会有这个问题的，但是我们很少这么干😂感兴趣的同学可以看接下来的渲染分析）

    而解决这种问题的方案主要有这几种

    1. 滚动加载，逐步渲染DOM（分页，一个意思）。
    2. 通过合理的逻辑来限制仅渲染可视区域部分。
    3. 算是1的变种，写一个异步循环渲染，通过异步的方式，给浏览器执行其它task的机会。（React异步渲染可以关注一下哦）

```
function fnthUglyNumber(n) {
   
}
```
&emsp;&emsp;结果提交解答的时候，提示：超出时间限制。很明显，这种计算方式，当N偏大的时候，将会非常耗时。我测试了一下，当N等于1407的时候大概计算耗时为：8~9秒。所以，这种傻瓜式的计算，肯定是不会通过的啦。

