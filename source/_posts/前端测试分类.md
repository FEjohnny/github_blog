---
title: 前端测试分类
date: 2018-09-16 16:41:05
tags: [前端, 自动化, 测试]
---

&emsp;&emsp;前端测试分类

<!--more-->
前端测试分类

功能测试
服务器数据预期测试：主要针对用户在前端界面进行某种操作后，提交数据给后台后，测试后台能否返回预期的数据
界面功能测试：主要针对用户在前端界面进行某种交互性操作后，测试能否获取预期的功能、界面交互
兼容性测试
多浏览器测试
性能测试
白屏时间：用户浏览器输入网址后至浏览器出现至少1px画面为止。
首屏时间：用户浏览器首屏内所有的元素呈现所花费时间。
页面回归时间：用户浏览器非第一次加载所有的元素呈现所花费时间。
用户可操作时间(dom ready) ：网站某些功能可以使用的时间。
页面总下载时间(onload):网站中所有资源加载完成并且可用时间。
质量测试
https://developer.yahoo.com/performance/rules.html?guccounter=1
界面样式测试（ui测试）
固定界面样式测试：主要针对文字内容不变的区域，例如页面的页头，页脚这类结构、内容不变的区域，而测试一般通过截图对比解决。
结构不变界面样式测试：主要针对结构不变的区域，例如新闻区域这类结构不变，内容变化的区域，这类测试一般通过DOM元素对比解决。
计算样式测试：主要针对计算样式不变的区域，这类测试一般通过比较计算样式解决，但是这种测试不推荐，因为测试成本比较大。

	一个标准的互联网应用产品的前端部分，我粗略估计大概有20%的业务基础代码比较稳定，比如通用组件、通用算法和数据模块等，可以针对这些建立复杂一些的API和GUI测试用例来保证质量。剩下80%的部分不是很稳定，每天都在迭代，针对他们维护case的成本非常高。目前业界中号称做了自动化测试的项目，也大多是在做那稳定的20%。
	12年的时候还在百度，当时有同事去美国参加velocity，twitter分享了一下他们的开发流程，其中有一个环节就是页面对比监控，利用了一个叫pdiff的工具，每次提交代码，会自动对比页面之间的差异然后提醒测试人员注意回归。这也是一个典型的GUI测试零成本维护用例的案例。不过pdiff这个工具是基于像素对比的，误报率比较高，所以去年我做了一个这个项目：fouber/page-monitor · GitHub 基于DOM树的diff，这样就能很大程度上自主控制要监控的元素，可以设置监控样式、文本的变化，比起像素diff智能了一些。
	其工作原理就是利用phantom或其他headless浏览器访问页面，然后截图，然后执行一段js，遍历整个dom树，获取元素计算样式和元素内文本内容，构造出一个JSON结构，然后每次diff这个json来判断页面差异，并标记在截图上展示。dom树的diff过程有点类似react的虚拟dom树diff。



这个搞笑：

	正常流程：前期投入资源测试 / 提高长期平均劳动效率 / 减少出事概率 / 员工在相同的时间可以做更多的事情 / 降低企业成本

	国内互联网行业：出事？加班就好了，反正是免费的 / 降低企业成本



	挺多做自动化测试，似乎都走进一个怪圈，技术方案很屌，但是测试效果并不是很好（为何？）

	觉得自动化测试难还是难在编写脚本，因为这玩意儿跟业务关系太紧密，尼玛天天改，于是经常改的地方根本没有人敢去写case。那就对了，频繁改的东西最该测，但是没的测，那要之何用？

	Jasmine 和 Mocha 是最流行的 JavaScript 单元测试框架，Jasmine 主要配合 AngularJS 进行单元测试，而 Mocha 则与 ReactJS 配合使用。vue用的mocha + chai或者jest。angular用的karma和jasmine

	mocha支持任何可以抛出一个错误的断言模块。例如：should.js、better-assert、expect.js、unexpected、chai等。这些断言库各有各的特点，大家可以了解一下它们的特点，根据使用场景来选择断言库。
	不建议在mocha测试框架中使用箭头函数。箭头函数语法中对this的绑定让会用例函数没办法访问Mocha框架上下文中定义的一些函数，例如this.timeout(1000)在箭头函数中就无法得到正确的结果。
我对这里的理解是：mocha会把用例函数注册到自身的某个属性中，通过属性调用的使用，正常函数可以访问到mocha的其他属性，但是箭头函数不行，就像下面的代码一样：

	测试主要使用到的工具是测试框架、断言库以及代码覆盖率工具：
测试框架：Mocha、Jasmine等等，测试主要提供了清晰简明的语法来描述测试用例，以及对测试用例分组，测试框架会抓取到代码抛出的AssertionError，并增加一大堆附加信息，比如那个用例挂了，为什么挂等等。测试框架通常提供TDD（测试驱动开发）或BDD（行为驱动开发）的测试语法来编写测试用例，关于TDD和BDD的对比可以看一篇比较知名的文章The Difference Between TDD and BDD。不同的测试框架支持不同的测试语法，比如Mocha既支持TDD也支持BDD，而Jasmine只支持BDD。这里后续以Mocha的BDD语法为例
2. 断言库：Should.js、chai、expect.js等等，断言库提供了很多语义化的方法来对值做各种各样的判断。当然也可以不用断言库，Node.js中也可以直接使用原生assert库。这里后续以Should.js为例

should.js - BDD style shown throughout these docs
expect.js - expect() style assertions
chai - expect(), assert() and should-style assertions
better-assert - C-style self-documenting assert()
unexpected - “the extensible BDD assertion toolkit”
代码覆盖率：istanbul等等为代码在语法级分支上打点，运行了打点后的代码，根据运行结束后收集到的信息和打点时的信息来统计出当前测试用例的对源码的覆盖情况。
	

